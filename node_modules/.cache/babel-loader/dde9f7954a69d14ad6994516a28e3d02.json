{"ast":null,"code":"const TrieNode = require('./trieNode');\n\nconst ethUtil = require('ethereumjs-util');\n\nconst matchingNibbleLength = require('./util').matchingNibbleLength;\n/**\n * Returns a merkle proof for a given key\n * @method Trie.prove\n * @param {Trie} trie\n * @param {String} key\n * @param {Function} cb A callback `Function` (arguments {Error} `err`, {Array.<TrieNode>} `proof`)\n */\n\n\nexports.prove = function (trie, key, cb) {\n  var nodes;\n  trie.findPath(key, function (err, node, remaining, stack) {\n    if (err) return cb(err);\n    if (remaining.length > 0) return cb(new Error('Node does not contain the key'));\n    nodes = stack;\n    var p = [];\n\n    for (var i = 0; i < nodes.length; i++) {\n      var rlpNode = nodes[i].serialize();\n\n      if (rlpNode.length >= 32 || i === 0) {\n        p.push(rlpNode);\n      }\n    }\n\n    cb(null, p);\n  });\n};\n/**\n * Verifies a merkle proof for a given key\n * @method Trie.verifyProof\n * @param {Buffer} rootHash\n * @param {String} key\n * @param {Array.<TrieNode>} proof\n * @param {Function} cb A callback `Function` (arguments {Error} `err`, {String} `val`)\n */\n\n\nexports.verifyProof = function (rootHash, key, proof, cb) {\n  key = TrieNode.stringToNibbles(key);\n  var wantHash = ethUtil.toBuffer(rootHash);\n\n  for (var i = 0; i < proof.length; i++) {\n    var p = ethUtil.toBuffer(proof[i]);\n    var hash = ethUtil.sha3(proof[i]);\n\n    if (Buffer.compare(hash, wantHash)) {\n      return cb(new Error('Bad proof node ' + i + ': hash mismatch'));\n    }\n\n    var node = new TrieNode(ethUtil.rlp.decode(p));\n    var cld;\n\n    if (node.type === 'branch') {\n      if (key.length === 0) {\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (branch)'));\n        }\n\n        return cb(null, node.value);\n      }\n\n      cld = node.raw[key[0]];\n      key = key.slice(1);\n\n      if (cld.length === 2) {\n        var embeddedNode = new TrieNode(cld);\n\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (embeddedNode)'));\n        }\n\n        if (matchingNibbleLength(embeddedNode.key, key) !== embeddedNode.key.length) {\n          return cb(new Error('Key length does not match with the proof one (embeddedNode)'));\n        }\n\n        key = key.slice(embeddedNode.key.length);\n\n        if (key.length !== 0) {\n          return cb(new Error('Key does not match with the proof one (embeddedNode)'));\n        }\n\n        return cb(null, embeddedNode.value);\n      } else {\n        wantHash = cld;\n      }\n    } else if (node.type === 'extention' || node.type === 'leaf') {\n      if (matchingNibbleLength(node.key, key) !== node.key.length) {\n        return cb(new Error('Key does not match with the proof one (extention|leaf)'));\n      }\n\n      cld = node.value;\n      key = key.slice(node.key.length);\n\n      if (key.length === 0 || cld.length === 17 && key.length === 1) {\n        // The value is in an embedded branch. Extract it.\n        if (cld.length === 17) {\n          cld = cld[key[0]][1];\n          key = key.slice(1);\n        }\n\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (extention|leaf)'));\n        }\n\n        return cb(null, cld);\n      } else {\n        wantHash = cld;\n      }\n    } else {\n      return cb(new Error('Invalid node type'));\n    }\n  }\n\n  cb(new Error('Unexpected end of proof'));\n};","map":{"version":3,"sources":["/Users/piyushmaheshwari/Downloads/pos-plasma-tutorial-exit-pos-plasma/node_modules/merkle-patricia-tree/proof.js"],"names":["TrieNode","require","ethUtil","matchingNibbleLength","exports","prove","trie","key","cb","nodes","findPath","err","node","remaining","stack","length","Error","p","i","rlpNode","serialize","push","verifyProof","rootHash","proof","stringToNibbles","wantHash","toBuffer","hash","sha3","Buffer","compare","rlp","decode","cld","type","value","raw","slice","embeddedNode"],"mappings":"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","sourcesContent":["const TrieNode = require('./trieNode')\nconst ethUtil = require('ethereumjs-util')\nconst matchingNibbleLength = require('./util').matchingNibbleLength\n\n/**\n * Returns a merkle proof for a given key\n * @method Trie.prove\n * @param {Trie} trie\n * @param {String} key\n * @param {Function} cb A callback `Function` (arguments {Error} `err`, {Array.<TrieNode>} `proof`)\n */\nexports.prove = function (trie, key, cb) {\n  var nodes\n\n  trie.findPath(key, function (err, node, remaining, stack) {\n    if (err) return cb(err)\n    if (remaining.length > 0) return cb(new Error('Node does not contain the key'))\n    nodes = stack\n    var p = []\n    for (var i = 0; i < nodes.length; i++) {\n      var rlpNode = nodes[i].serialize()\n\n      if ((rlpNode.length >= 32) || (i === 0)) {\n        p.push(rlpNode)\n      }\n    }\n    cb(null, p)\n  })\n}\n\n/**\n * Verifies a merkle proof for a given key\n * @method Trie.verifyProof\n * @param {Buffer} rootHash\n * @param {String} key\n * @param {Array.<TrieNode>} proof\n * @param {Function} cb A callback `Function` (arguments {Error} `err`, {String} `val`)\n */\nexports.verifyProof = function (rootHash, key, proof, cb) {\n  key = TrieNode.stringToNibbles(key)\n  var wantHash = ethUtil.toBuffer(rootHash)\n  for (var i = 0; i < proof.length; i++) {\n    var p = ethUtil.toBuffer(proof[i])\n    var hash = ethUtil.sha3(proof[i])\n    if (Buffer.compare(hash, wantHash)) {\n      return cb(new Error('Bad proof node ' + i + ': hash mismatch'))\n    }\n    var node = new TrieNode(ethUtil.rlp.decode(p))\n    var cld\n    if (node.type === 'branch') {\n      if (key.length === 0) {\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (branch)'))\n        }\n        return cb(null, node.value)\n      }\n      cld = node.raw[key[0]]\n      key = key.slice(1)\n      if (cld.length === 2) {\n        var embeddedNode = new TrieNode(cld)\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (embeddedNode)'))\n        }\n\n        if (matchingNibbleLength(embeddedNode.key, key) !== embeddedNode.key.length) {\n          return cb(new Error('Key length does not match with the proof one (embeddedNode)'))\n        }\n        key = key.slice(embeddedNode.key.length)\n        if (key.length !== 0) {\n          return cb(new Error('Key does not match with the proof one (embeddedNode)'))\n        }\n        return cb(null, embeddedNode.value)\n      } else {\n        wantHash = cld\n      }\n    } else if ((node.type === 'extention') || (node.type === 'leaf')) {\n      if (matchingNibbleLength(node.key, key) !== node.key.length) {\n        return cb(new Error('Key does not match with the proof one (extention|leaf)'))\n      }\n      cld = node.value\n      key = key.slice(node.key.length)\n      if (key.length === 0 || (cld.length === 17 && key.length === 1)) {\n        // The value is in an embedded branch. Extract it.\n        if (cld.length === 17) {\n          cld = cld[key[0]][1]\n          key = key.slice(1)\n        }\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (extention|leaf)'))\n        }\n        return cb(null, cld)\n      } else {\n        wantHash = cld\n      }\n    } else {\n      return cb(new Error('Invalid node type'))\n    }\n  }\n  cb(new Error('Unexpected end of proof'))\n}\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"const assert = require('assert');\n\nconst levelup = require('levelup');\n\nconst memdown = require('memdown');\n\nconst async = require('async');\n\nconst rlp = require('rlp');\n\nconst ethUtil = require('ethereumjs-util');\n\nconst semaphore = require('semaphore');\n\nconst TrieNode = require('./trieNode');\n\nconst ReadStream = require('./readStream');\n\nconst PrioritizedTaskExecutor = require('./prioritizedTaskExecutor');\n\nconst matchingNibbleLength = require('./util').matchingNibbleLength;\n\nconst doKeysMatch = require('./util').doKeysMatch;\n\nconst callTogether = require('./util').callTogether;\n\nconst asyncFirstSeries = require('./util').asyncFirstSeries;\n\nmodule.exports = Trie;\n/**\n * Use `require('merkel-patricia-tree')` for the base interface. In Ethereum applications stick with the Secure Trie Overlay `require('merkel-patricia-tree/secure')`. The API for the raw and the secure interface are about the same\n * @class Trie\n * @param {Object} [db] An instance of [levelup](https://github.com/rvagg/node-levelup/) or a compatible API. If the db is `null` or left undefined, then the trie will be stored in memory via [memdown](https://github.com/rvagg/memdown)\n * @param {Buffer|String} [root]` A hex `String` or `Buffer` for the root of a previously stored trie\n * @prop {Buffer} root The current root of the `trie`\n * @prop {Boolean} isCheckpoint  determines if you are saving to a checkpoint or directly to the db\n * @prop {Buffer} EMPTY_TRIE_ROOT the Root for an empty trie\n */\n\nfunction Trie(db, root) {\n  var self = this;\n  this.EMPTY_TRIE_ROOT = ethUtil.SHA3_RLP;\n  this.sem = semaphore(1); // setup dbs\n\n  this.db = db || levelup('', {\n    db: memdown\n  });\n  this._getDBs = [this.db];\n  this._putDBs = [this.db];\n  Object.defineProperty(this, 'root', {\n    set: function (value) {\n      if (value) {\n        value = ethUtil.toBuffer(value);\n        assert(value.length === 32, 'Invalid root length. Roots are 32 bytes');\n      } else {\n        value = self.EMPTY_TRIE_ROOT;\n      }\n\n      this._root = value;\n    },\n    get: function () {\n      return this._root;\n    }\n  });\n  this.root = root;\n}\n/**\n * Gets a value given a `key`\n * @method get\n * @param {Buffer|String} key - the key to search for\n * @param {Function} cb A callback `Function` which is given the arguments `err` - for errors that may have occured and `value` - the found value in a `Buffer` or if no value was found `null`\n */\n\n\nTrie.prototype.get = function (key, cb) {\n  var self = this;\n  key = ethUtil.toBuffer(key);\n  self.findPath(key, function (err, node, remainder, stack) {\n    var value = null;\n\n    if (node && remainder.length === 0) {\n      value = node.value;\n    }\n\n    cb(err, value);\n  });\n};\n/**\n * Stores a given `value` at the given `key`\n * @method put\n * @param {Buffer|String} key\n * @param {Buffer|String} Value\n * @param {Function} cb A callback `Function` which is given the argument `err` - for errors that may have occured\n */\n\n\nTrie.prototype.put = function (key, value, cb) {\n  var self = this;\n  key = ethUtil.toBuffer(key);\n  value = ethUtil.toBuffer(value);\n\n  if (!value || value.toString() === '') {\n    self.del(key, cb);\n  } else {\n    cb = callTogether(cb, self.sem.leave);\n    self.sem.take(function () {\n      if (self.root.toString('hex') !== ethUtil.SHA3_RLP.toString('hex')) {\n        // first try to find the give key or its nearst node\n        self.findPath(key, function (err, foundValue, keyRemainder, stack) {\n          if (err) {\n            return cb(err);\n          } // then update\n\n\n          self._updateNode(key, value, keyRemainder, stack, cb);\n        });\n      } else {\n        self._createInitialNode(key, value, cb); // if no root initialize this trie\n\n      }\n    });\n  }\n};\n/**\n * deletes a value given a `key`\n * @method del\n * @param {Buffer|String} key\n * @param {Function} callback the callback `Function`\n */\n\n\nTrie.prototype.del = function (key, cb) {\n  var self = this;\n  key = ethUtil.toBuffer(key);\n  cb = callTogether(cb, self.sem.leave);\n  self.sem.take(function () {\n    self.findPath(key, function (err, foundValue, keyRemainder, stack) {\n      if (err) {\n        return cb(err);\n      }\n\n      if (foundValue) {\n        self._deleteNode(key, stack, cb);\n      } else {\n        cb();\n      }\n    });\n  });\n};\n/**\n * Retrieves a raw value in the underlying db\n * @method getRaw\n * @param {Buffer} key\n * @param {Function} callback A callback `Function`, which is given the arguments `err` - for errors that may have occured and `value` - the found value in a `Buffer` or if no value was found `null`.\n */\n\n\nTrie.prototype.getRaw = function (key, cb) {\n  key = ethUtil.toBuffer(key);\n\n  function dbGet(db, cb2) {\n    db.get(key, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, function (err, foundNode) {\n      if (err || !foundNode) {\n        cb2(null, null);\n      } else {\n        cb2(null, foundNode);\n      }\n    });\n  }\n\n  asyncFirstSeries(this._getDBs, dbGet, cb);\n}; // retrieves a node from dbs by hash\n\n\nTrie.prototype._lookupNode = function (node, cb) {\n  if (TrieNode.isRawNode(node)) {\n    cb(new TrieNode(node));\n  } else {\n    this.getRaw(node, function (err, value) {\n      if (err) {\n        throw err;\n      }\n\n      if (value) {\n        value = new TrieNode(rlp.decode(value));\n      }\n\n      cb(value);\n    });\n  }\n}; // TODO: remove the proxy method when changing the caching\n\n\nTrie.prototype._putRaw = function (key, val, cb) {\n  function dbPut(db, cb2) {\n    db.put(key, val, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, cb2);\n  }\n\n  async.each(this._putDBs, dbPut, cb);\n};\n/**\n * Writes a value directly to the underlining db\n * @method putRaw\n * @param {Buffer|String} key The key as a `Buffer` or `String`\n * @param {Buffer} value The value to be stored\n * @param {Function} callback A callback `Function`, which is given the argument `err` - for errors that may have occured\n */\n\n\nTrie.prototype.putRaw = Trie.prototype._putRaw;\n/**\n * Removes a raw value in the underlying db\n * @method delRaw\n * @param {Buffer|String} key\n * @param {Function} callback A callback `Function`, which is given the argument `err` - for errors that may have occured\n */\n\nTrie.prototype.delRaw = function (key, cb) {\n  function del(db, cb2) {\n    db.del(key, {\n      keyEncoding: 'binary'\n    }, cb2);\n  }\n\n  async.each(this._putDBs, del, cb);\n}; // writes a single node to dbs\n\n\nTrie.prototype._putNode = function (node, cb) {\n  var hash = node.hash();\n  var serialized = node.serialize();\n\n  this._putRaw(hash, serialized, cb);\n}; // writes many nodes to db\n\n\nTrie.prototype._batchNodes = function (opStack, cb) {\n  function dbBatch(db, cb) {\n    db.batch(opStack, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, cb);\n  }\n\n  async.each(this._putDBs, dbBatch, cb);\n};\n/**\n * Trys to find a path to the node for the given key\n * It returns a `stack` of nodes to the closet node\n * @method findPath\n * @param {String|Buffer} - key - the search key\n * @param {Function} - cb - the callback function. Its is given the following\n * arguments\n *  - err - any errors encontered\n *  - node - the last node found\n *  - keyRemainder - the remaining key nibbles not accounted for\n *  - stack - an array of nodes that forms the path to node we are searching for\n */\n\n\nTrie.prototype.findPath = function (targetKey, cb) {\n  var self = this;\n  var root = self.root;\n  var stack = [];\n  targetKey = TrieNode.stringToNibbles(targetKey);\n\n  this._walkTrie(root, processNode, cb);\n\n  function processNode(nodeRef, node, keyProgress, walkController) {\n    var nodeKey = node.key || [];\n    var keyRemainder = targetKey.slice(matchingNibbleLength(keyProgress, targetKey));\n    var matchingLen = matchingNibbleLength(keyRemainder, nodeKey);\n    stack.push(node);\n\n    if (node.type === 'branch') {\n      if (keyRemainder.length === 0) {\n        walkController.return(null, node, [], stack); // we exhausted the key without finding a node\n      } else {\n        var branchIndex = keyRemainder[0];\n        var branchNode = node.getValue(branchIndex);\n\n        if (!branchNode) {\n          // there are no more nodes to find and we didn't find the key\n          walkController.return(null, null, keyRemainder, stack);\n        } else {\n          // node found, continuing search\n          walkController.only(branchIndex);\n        }\n      }\n    } else if (node.type === 'leaf') {\n      if (doKeysMatch(keyRemainder, nodeKey)) {\n        // keys match, return node with empty key\n        walkController.return(null, node, [], stack);\n      } else {\n        // reached leaf but keys dont match\n        walkController.return(null, null, keyRemainder, stack);\n      }\n    } else if (node.type === 'extention') {\n      if (matchingLen !== nodeKey.length) {\n        // keys dont match, fail\n        walkController.return(null, null, keyRemainder, stack);\n      } else {\n        // keys match, continue search\n        walkController.next();\n      }\n    }\n  }\n};\n/*\n * Finds all nodes that store k,v values\n */\n\n\nTrie.prototype._findNode = function (key, root, stack, cb) {\n  this.findPath(key, function () {\n    cb.apply(null, arguments);\n  });\n};\n/*\n * Finds all nodes that store k,v values\n */\n\n\nTrie.prototype._findValueNodes = function (onFound, cb) {\n  this._walkTrie(this.root, function (nodeRef, node, key, walkController) {\n    var fullKey = key;\n\n    if (node.key) {\n      fullKey = key.concat(node.key);\n    }\n\n    if (node.type === 'leaf') {\n      // found leaf node!\n      onFound(nodeRef, node, fullKey, walkController.next);\n    } else if (node.type === 'branch' && node.value) {\n      // found branch with value\n      onFound(nodeRef, node, fullKey, walkController.next);\n    } else {\n      // keep looking for value nodes\n      walkController.next();\n    }\n  }, cb);\n};\n/*\n * Finds all nodes that are stored directly in the db\n * (some nodes are stored raw inside other nodes)\n */\n\n\nTrie.prototype._findDbNodes = function (onFound, cb) {\n  this._walkTrie(this.root, function (nodeRef, node, key, walkController) {\n    if (TrieNode.isRawNode(nodeRef)) {\n      walkController.next();\n    } else {\n      onFound(nodeRef, node, key, walkController.next);\n    }\n  }, cb);\n};\n/**\n * Updates a node\n * @method _updateNode\n * @param {Buffer} key\n * @param {Buffer| String} value\n * @param {Array} keyRemainder\n * @param {Array} stack -\n * @param {Function} cb - the callback\n */\n\n\nTrie.prototype._updateNode = function (key, value, keyRemainder, stack, cb) {\n  var toSave = [];\n  var lastNode = stack.pop(); // add the new nodes\n\n  key = TrieNode.stringToNibbles(key); // Check if the last node is a leaf and the key matches to this\n\n  var matchLeaf = false;\n\n  if (lastNode.type === 'leaf') {\n    var l = 0;\n\n    for (var i = 0; i < stack.length; i++) {\n      var n = stack[i];\n\n      if (n.type === 'branch') {\n        l++;\n      } else {\n        l += n.key.length;\n      }\n    }\n\n    if (matchingNibbleLength(lastNode.key, key.slice(l)) === lastNode.key.length && keyRemainder.length === 0) {\n      matchLeaf = true;\n    }\n  }\n\n  if (matchLeaf) {\n    // just updating a found value\n    lastNode.value = value;\n    stack.push(lastNode);\n  } else if (lastNode.type === 'branch') {\n    stack.push(lastNode);\n\n    if (keyRemainder !== 0) {\n      // add an extention to a branch node\n      keyRemainder.shift(); // create a new leaf\n\n      var newLeaf = new TrieNode('leaf', keyRemainder, value);\n      stack.push(newLeaf);\n    } else {\n      lastNode.value = value;\n    }\n  } else {\n    // create a branch node\n    var lastKey = lastNode.key;\n    var matchingLength = matchingNibbleLength(lastKey, keyRemainder);\n    var newBranchNode = new TrieNode('branch'); // create a new extention node\n\n    if (matchingLength !== 0) {\n      var newKey = lastNode.key.slice(0, matchingLength);\n      var newExtNode = new TrieNode('extention', newKey, value);\n      stack.push(newExtNode);\n      lastKey.splice(0, matchingLength);\n      keyRemainder.splice(0, matchingLength);\n    }\n\n    stack.push(newBranchNode);\n\n    if (lastKey.length !== 0) {\n      var branchKey = lastKey.shift();\n\n      if (lastKey.length !== 0 || lastNode.type === 'leaf') {\n        // shriking extention or leaf\n        lastNode.key = lastKey;\n\n        var formatedNode = this._formatNode(lastNode, false, toSave);\n\n        newBranchNode.setValue(branchKey, formatedNode);\n      } else {\n        // remove extention or attaching\n        this._formatNode(lastNode, false, true, toSave);\n\n        newBranchNode.setValue(branchKey, lastNode.value);\n      }\n    } else {\n      newBranchNode.value = lastNode.value;\n    }\n\n    if (keyRemainder.length !== 0) {\n      keyRemainder.shift(); // add a leaf node to the new branch node\n\n      var newLeafNode = new TrieNode('leaf', keyRemainder, value);\n      stack.push(newLeafNode);\n    } else {\n      newBranchNode.value = value;\n    }\n  }\n\n  this._saveStack(key, stack, toSave, cb);\n}; // walk tree\n\n\nTrie.prototype._walkTrie = function (root, onNode, onDone) {\n  var self = this;\n  root = root || self.root;\n\n  onDone = onDone || function () {};\n\n  var aborted = false;\n  var returnValues = [];\n\n  if (root.toString('hex') === ethUtil.SHA3_RLP.toString('hex')) {\n    return onDone();\n  }\n\n  self._lookupNode(root, function (node) {\n    processNode(root, node, null, function (err) {\n      if (err) {\n        return onDone(err);\n      }\n\n      onDone.apply(null, returnValues);\n    });\n  }); // the maximum pool size should be high enough to utilise the parallelizability of reading nodes from disk and\n  // low enough to utilize the prioritisation of node lookup.\n\n\n  var maxPoolSize = 500;\n  var taskExecutor = new PrioritizedTaskExecutor(maxPoolSize);\n\n  function processNode(nodeRef, node, key, cb) {\n    if (!node) return cb();\n    if (aborted) return cb();\n    var stopped = false;\n    key = key || [];\n    var walkController = {\n      stop: function () {\n        stopped = true;\n        cb();\n      },\n      // end all traversal and return values to the onDone cb\n      return: function () {\n        aborted = true;\n        returnValues = arguments;\n        cb();\n      },\n      next: function () {\n        if (aborted) {\n          return cb();\n        }\n\n        if (stopped) {\n          return cb();\n        }\n\n        var children = node.getChildren();\n        async.forEachOf(children, function (childData, index, cb) {\n          var keyExtension = childData[0];\n          var childRef = childData[1];\n          var childKey = key.concat(keyExtension);\n          var priority = childKey.length;\n          taskExecutor.execute(priority, function (taskCallback) {\n            self._lookupNode(childRef, function (childNode) {\n              taskCallback();\n              processNode(childRef, childNode, childKey, cb);\n            });\n          });\n        }, cb);\n      },\n      only: function (childIndex) {\n        var childRef = node.getValue(childIndex);\n        var childKey = key.slice();\n        childKey.push(childIndex);\n        var priority = childKey.length;\n        taskExecutor.execute(priority, function (taskCallback) {\n          self._lookupNode(childRef, function (childNode) {\n            taskCallback();\n            processNode(childRef, childNode, childKey, cb);\n          });\n        });\n      }\n    };\n    onNode(nodeRef, node, key, walkController);\n  }\n};\n/**\n * saves a stack\n * @method _saveStack\n * @param {Array} key - the key. Should follow the stack\n * @param {Array} stack - a stack of nodes to the value given by the key\n * @param {Array} opStack - a stack of levelup operations to commit at the end of this funciton\n * @param {Function} cb\n */\n\n\nTrie.prototype._saveStack = function (key, stack, opStack, cb) {\n  var lastRoot; // update nodes\n\n  while (stack.length) {\n    var node = stack.pop();\n\n    if (node.type === 'leaf') {\n      key.splice(key.length - node.key.length);\n    } else if (node.type === 'extention') {\n      key.splice(key.length - node.key.length);\n\n      if (lastRoot) {\n        node.value = lastRoot;\n      }\n    } else if (node.type === 'branch') {\n      if (lastRoot) {\n        var branchKey = key.pop();\n        node.setValue(branchKey, lastRoot);\n      }\n    }\n\n    lastRoot = this._formatNode(node, stack.length === 0, opStack);\n  }\n\n  if (lastRoot) {\n    this.root = lastRoot;\n  }\n\n  this._batchNodes(opStack, cb);\n};\n\nTrie.prototype._deleteNode = function (key, stack, cb) {\n  function processBranchNode(key, branchKey, branchNode, parentNode, stack) {\n    // branchNode is the node ON the branch node not THE branch node\n    var branchNodeKey = branchNode.key;\n\n    if (!parentNode || parentNode.type === 'branch') {\n      // branch->?\n      if (parentNode) {\n        stack.push(parentNode);\n      }\n\n      if (branchNode.type === 'branch') {\n        // create an extention node\n        // branch->extention->branch\n        var extentionNode = new TrieNode('extention', [branchKey], null);\n        stack.push(extentionNode);\n        key.push(branchKey);\n      } else {\n        // branch key is an extention or a leaf\n        // branch->(leaf or extention)\n        branchNodeKey.unshift(branchKey);\n        branchNode.key = branchNodeKey; // hackery. This is equvilant to array.concat except we need keep the\n        // rerfance to the `key` that was passed in.\n\n        branchNodeKey.unshift(0);\n        branchNodeKey.unshift(key.length);\n        key.splice.apply(key, branchNodeKey);\n      }\n\n      stack.push(branchNode);\n    } else {\n      // parent is a extention\n      var parentKey = parentNode.key;\n\n      if (branchNode.type === 'branch') {\n        // ext->branch\n        parentKey.push(branchKey);\n        key.push(branchKey);\n        parentNode.key = parentKey;\n        stack.push(parentNode);\n      } else {\n        // branch node is an leaf or extention and parent node is an exstention\n        // add two keys together\n        // dont push the parent node\n        branchNodeKey.unshift(branchKey);\n        key = key.concat(branchNodeKey);\n        parentKey = parentKey.concat(branchNodeKey);\n        branchNode.key = parentKey;\n      }\n\n      stack.push(branchNode);\n    }\n\n    return key;\n  }\n\n  var lastNode = stack.pop();\n  var parentNode = stack.pop();\n  var opStack = [];\n  var self = this;\n\n  if (!Array.isArray(key)) {\n    // convert key to nibbles\n    key = TrieNode.stringToNibbles(key);\n  }\n\n  if (!parentNode) {\n    // the root here has to be a leaf.\n    this.root = this.EMPTY_TRIE_ROOT;\n    cb();\n  } else {\n    if (lastNode.type === 'branch') {\n      lastNode.value = null;\n    } else {\n      // the lastNode has to be a leaf if its not a branch. And a leaf's parent\n      // if it has one must be a branch.\n      var lastNodeKey = lastNode.key;\n      key.splice(key.length - lastNodeKey.length); // delete the value\n\n      this._formatNode(lastNode, false, true, opStack);\n\n      parentNode.setValue(key.pop(), null);\n      lastNode = parentNode;\n      parentNode = stack.pop();\n    } // nodes on the branch\n\n\n    var branchNodes = []; // count the number of nodes on the branch\n\n    lastNode.raw.forEach(function (node, i) {\n      var val = lastNode.getValue(i);\n      if (val) branchNodes.push([i, val]);\n    }); // if there is only one branch node left, collapse the branch node\n\n    if (branchNodes.length === 1) {\n      // add the one remaing branch node to node above it\n      var branchNode = branchNodes[0][1];\n      var branchNodeKey = branchNodes[0][0]; // look up node\n\n      this._lookupNode(branchNode, function (foundNode) {\n        key = processBranchNode(key, branchNodeKey, foundNode, parentNode, stack, opStack);\n\n        self._saveStack(key, stack, opStack, cb);\n      });\n    } else {\n      // simple removing a leaf and recaluclation the stack\n      if (parentNode) {\n        stack.push(parentNode);\n      }\n\n      stack.push(lastNode);\n\n      self._saveStack(key, stack, opStack, cb);\n    }\n  }\n}; // Creates the initial node from an empty tree\n\n\nTrie.prototype._createInitialNode = function (key, value, cb) {\n  var newNode = new TrieNode('leaf', key, value);\n  this.root = newNode.hash();\n\n  this._putNode(newNode, cb);\n}; // formats node to be saved by levelup.batch.\n// returns either the hash that will be used key or the rawNode\n\n\nTrie.prototype._formatNode = function (node, topLevel, remove, opStack) {\n  if (arguments.length === 3) {\n    opStack = remove;\n    remove = false;\n  }\n\n  var rlpNode = node.serialize();\n\n  if (rlpNode.length >= 32 || topLevel) {\n    var hashRoot = node.hash();\n\n    if (remove && this.isCheckpoint) {\n      opStack.push({\n        type: 'del',\n        key: hashRoot\n      });\n    } else {\n      opStack.push({\n        type: 'put',\n        key: hashRoot,\n        value: rlpNode\n      });\n    }\n\n    return hashRoot;\n  }\n\n  return node.raw;\n};\n/**\n * The `data` event is given an `Object` hat has two properties; the `key` and the `value`. Both should be Buffers.\n * @method createReadStream\n * @return {stream.Readable} Returns a [stream](https://nodejs.org/dist/latest-v5.x/docs/api/stream.html#stream_class_stream_readable) of the contents of the `trie`\n */\n\n\nTrie.prototype.createReadStream = function () {\n  return new ReadStream(this);\n}; // creates a new trie backed by the same db\n// and starting at the same root\n\n\nTrie.prototype.copy = function () {\n  return new Trie(this.db, this.root);\n};\n/**\n * The given hash of operations (key additions or deletions) are executed on the DB\n * @method batch\n * @example\n * var ops = [\n *    { type: 'del', key: 'father' }\n *  , { type: 'put', key: 'name', value: 'Yuri Irsenovich Kim' }\n *  , { type: 'put', key: 'dob', value: '16 February 1941' }\n *  , { type: 'put', key: 'spouse', value: 'Kim Young-sook' }\n *  , { type: 'put', key: 'occupation', value: 'Clown' }\n * ]\n * trie.batch(ops)\n * @param {Array} ops\n * @param {Function} cb\n */\n\n\nTrie.prototype.batch = function (ops, cb) {\n  var self = this;\n  async.eachSeries(ops, function (op, cb2) {\n    if (op.type === 'put') {\n      self.put(op.key, op.value, cb2);\n    } else if (op.type === 'del') {\n      self.del(op.key, cb2);\n    } else {\n      cb2();\n    }\n  }, cb);\n};\n/**\n * Checks if a given root exists\n * @method checkRoot\n * @param {Buffer} root\n * @param {Function} cb\n */\n\n\nTrie.prototype.checkRoot = function (root, cb) {\n  root = ethUtil.toBuffer(root);\n\n  this._lookupNode(root, function (value) {\n    cb(null, !!value);\n  });\n};","map":{"version":3,"sources":["/Users/piyushmaheshwari/Downloads/pos-plasma-tutorial-exit-pos-plasma/node_modules/merkle-patricia-tree/baseTrie.js"],"names":["assert","require","levelup","memdown","async","rlp","ethUtil","semaphore","TrieNode","ReadStream","PrioritizedTaskExecutor","matchingNibbleLength","doKeysMatch","callTogether","asyncFirstSeries","module","exports","Trie","db","root","self","EMPTY_TRIE_ROOT","SHA3_RLP","sem","_getDBs","_putDBs","Object","defineProperty","set","value","toBuffer","length","_root","get","prototype","key","cb","findPath","err","node","remainder","stack","put","toString","del","leave","take","foundValue","keyRemainder","_updateNode","_createInitialNode","_deleteNode","getRaw","dbGet","cb2","keyEncoding","valueEncoding","foundNode","_lookupNode","isRawNode","decode","_putRaw","val","dbPut","each","putRaw","delRaw","_putNode","hash","serialized","serialize","_batchNodes","opStack","dbBatch","batch","targetKey","stringToNibbles","_walkTrie","processNode","nodeRef","keyProgress","walkController","nodeKey","slice","matchingLen","push","type","return","branchIndex","branchNode","getValue","only","next","_findNode","apply","arguments","_findValueNodes","onFound","fullKey","concat","_findDbNodes","toSave","lastNode","pop","matchLeaf","l","i","n","shift","newLeaf","lastKey","matchingLength","newBranchNode","newKey","newExtNode","splice","branchKey","formatedNode","_formatNode","setValue","newLeafNode","_saveStack","onNode","onDone","aborted","returnValues","maxPoolSize","taskExecutor","stopped","stop","children","getChildren","forEachOf","childData","index","keyExtension","childRef","childKey","priority","execute","taskCallback","childNode","childIndex","lastRoot","processBranchNode","parentNode","branchNodeKey","extentionNode","unshift","parentKey","Array","isArray","lastNodeKey","branchNodes","raw","forEach","newNode","topLevel","remove","rlpNode","hashRoot","isCheckpoint","createReadStream","copy","ops","eachSeries","op","checkRoot"],"mappings":"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","sourcesContent":["const assert = require('assert')\nconst levelup = require('levelup')\nconst memdown = require('memdown')\nconst async = require('async')\nconst rlp = require('rlp')\nconst ethUtil = require('ethereumjs-util')\nconst semaphore = require('semaphore')\nconst TrieNode = require('./trieNode')\nconst ReadStream = require('./readStream')\nconst PrioritizedTaskExecutor = require('./prioritizedTaskExecutor')\nconst matchingNibbleLength = require('./util').matchingNibbleLength\nconst doKeysMatch = require('./util').doKeysMatch\nconst callTogether = require('./util').callTogether\nconst asyncFirstSeries = require('./util').asyncFirstSeries\n\nmodule.exports = Trie\n\n/**\n * Use `require('merkel-patricia-tree')` for the base interface. In Ethereum applications stick with the Secure Trie Overlay `require('merkel-patricia-tree/secure')`. The API for the raw and the secure interface are about the same\n * @class Trie\n * @param {Object} [db] An instance of [levelup](https://github.com/rvagg/node-levelup/) or a compatible API. If the db is `null` or left undefined, then the trie will be stored in memory via [memdown](https://github.com/rvagg/memdown)\n * @param {Buffer|String} [root]` A hex `String` or `Buffer` for the root of a previously stored trie\n * @prop {Buffer} root The current root of the `trie`\n * @prop {Boolean} isCheckpoint  determines if you are saving to a checkpoint or directly to the db\n * @prop {Buffer} EMPTY_TRIE_ROOT the Root for an empty trie\n */\nfunction Trie (db, root) {\n  var self = this\n  this.EMPTY_TRIE_ROOT = ethUtil.SHA3_RLP\n  this.sem = semaphore(1)\n\n  // setup dbs\n  this.db = db ||\n    levelup('', {\n      db: memdown\n    })\n\n  this._getDBs = [this.db]\n  this._putDBs = [this.db]\n\n  Object.defineProperty(this, 'root', {\n    set: function (value) {\n      if (value) {\n        value = ethUtil.toBuffer(value)\n        assert(value.length === 32, 'Invalid root length. Roots are 32 bytes')\n      } else {\n        value = self.EMPTY_TRIE_ROOT\n      }\n\n      this._root = value\n    },\n    get: function () {\n      return this._root\n    }\n  })\n\n  this.root = root\n}\n\n/**\n * Gets a value given a `key`\n * @method get\n * @param {Buffer|String} key - the key to search for\n * @param {Function} cb A callback `Function` which is given the arguments `err` - for errors that may have occured and `value` - the found value in a `Buffer` or if no value was found `null`\n */\nTrie.prototype.get = function (key, cb) {\n  var self = this\n\n  key = ethUtil.toBuffer(key)\n\n  self.findPath(key, function (err, node, remainder, stack) {\n    var value = null\n    if (node && remainder.length === 0) {\n      value = node.value\n    }\n\n    cb(err, value)\n  })\n}\n\n/**\n * Stores a given `value` at the given `key`\n * @method put\n * @param {Buffer|String} key\n * @param {Buffer|String} Value\n * @param {Function} cb A callback `Function` which is given the argument `err` - for errors that may have occured\n */\nTrie.prototype.put = function (key, value, cb) {\n  var self = this\n\n  key = ethUtil.toBuffer(key)\n  value = ethUtil.toBuffer(value)\n\n  if (!value || value.toString() === '') {\n    self.del(key, cb)\n  } else {\n    cb = callTogether(cb, self.sem.leave)\n\n    self.sem.take(function () {\n      if (self.root.toString('hex') !== ethUtil.SHA3_RLP.toString('hex')) {\n        // first try to find the give key or its nearst node\n        self.findPath(key, function (err, foundValue, keyRemainder, stack) {\n          if (err) {\n            return cb(err)\n          }\n          // then update\n          self._updateNode(key, value, keyRemainder, stack, cb)\n        })\n      } else {\n        self._createInitialNode(key, value, cb) // if no root initialize this trie\n      }\n    })\n  }\n}\n\n/**\n * deletes a value given a `key`\n * @method del\n * @param {Buffer|String} key\n * @param {Function} callback the callback `Function`\n */\nTrie.prototype.del = function (key, cb) {\n  var self = this\n\n  key = ethUtil.toBuffer(key)\n  cb = callTogether(cb, self.sem.leave)\n\n  self.sem.take(function () {\n    self.findPath(key, function (err, foundValue, keyRemainder, stack) {\n      if (err) {\n        return cb(err)\n      }\n      if (foundValue) {\n        self._deleteNode(key, stack, cb)\n      } else {\n        cb()\n      }\n    })\n  })\n}\n\n/**\n * Retrieves a raw value in the underlying db\n * @method getRaw\n * @param {Buffer} key\n * @param {Function} callback A callback `Function`, which is given the arguments `err` - for errors that may have occured and `value` - the found value in a `Buffer` or if no value was found `null`.\n */\nTrie.prototype.getRaw = function (key, cb) {\n  key = ethUtil.toBuffer(key)\n\n  function dbGet (db, cb2) {\n    db.get(key, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, function (err, foundNode) {\n      if (err || !foundNode) {\n        cb2(null, null)\n      } else {\n        cb2(null, foundNode)\n      }\n    })\n  }\n  asyncFirstSeries(this._getDBs, dbGet, cb)\n}\n\n// retrieves a node from dbs by hash\nTrie.prototype._lookupNode = function (node, cb) {\n  if (TrieNode.isRawNode(node)) {\n    cb(new TrieNode(node))\n  } else {\n    this.getRaw(node, function (err, value) {\n      if (err) {\n        throw err\n      }\n\n      if (value) {\n        value = new TrieNode(rlp.decode(value))\n      }\n\n      cb(value)\n    })\n  }\n}\n\n// TODO: remove the proxy method when changing the caching\nTrie.prototype._putRaw = function (key, val, cb) {\n  function dbPut (db, cb2) {\n    db.put(key, val, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, cb2)\n  }\n  async.each(this._putDBs, dbPut, cb)\n}\n\n/**\n * Writes a value directly to the underlining db\n * @method putRaw\n * @param {Buffer|String} key The key as a `Buffer` or `String`\n * @param {Buffer} value The value to be stored\n * @param {Function} callback A callback `Function`, which is given the argument `err` - for errors that may have occured\n */\nTrie.prototype.putRaw = Trie.prototype._putRaw\n\n/**\n * Removes a raw value in the underlying db\n * @method delRaw\n * @param {Buffer|String} key\n * @param {Function} callback A callback `Function`, which is given the argument `err` - for errors that may have occured\n */\nTrie.prototype.delRaw = function (key, cb) {\n  function del (db, cb2) {\n    db.del(key, {\n      keyEncoding: 'binary'\n    }, cb2)\n  }\n  async.each(this._putDBs, del, cb)\n}\n\n// writes a single node to dbs\nTrie.prototype._putNode = function (node, cb) {\n  var hash = node.hash()\n  var serialized = node.serialize()\n  this._putRaw(hash, serialized, cb)\n}\n\n// writes many nodes to db\nTrie.prototype._batchNodes = function (opStack, cb) {\n  function dbBatch (db, cb) {\n    db.batch(opStack, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, cb)\n  }\n\n  async.each(this._putDBs, dbBatch, cb)\n}\n\n/**\n * Trys to find a path to the node for the given key\n * It returns a `stack` of nodes to the closet node\n * @method findPath\n * @param {String|Buffer} - key - the search key\n * @param {Function} - cb - the callback function. Its is given the following\n * arguments\n *  - err - any errors encontered\n *  - node - the last node found\n *  - keyRemainder - the remaining key nibbles not accounted for\n *  - stack - an array of nodes that forms the path to node we are searching for\n */\n\nTrie.prototype.findPath = function (targetKey, cb) {\n  var self = this\n  var root = self.root\n  var stack = []\n  targetKey = TrieNode.stringToNibbles(targetKey)\n\n  this._walkTrie(root, processNode, cb)\n\n  function processNode (nodeRef, node, keyProgress, walkController) {\n    var nodeKey = node.key || []\n    var keyRemainder = targetKey.slice(matchingNibbleLength(keyProgress, targetKey))\n    var matchingLen = matchingNibbleLength(keyRemainder, nodeKey)\n\n    stack.push(node)\n\n    if (node.type === 'branch') {\n      if (keyRemainder.length === 0) {\n        walkController.return(null, node, [], stack)\n      // we exhausted the key without finding a node\n      } else {\n        var branchIndex = keyRemainder[0]\n        var branchNode = node.getValue(branchIndex)\n        if (!branchNode) {\n          // there are no more nodes to find and we didn't find the key\n          walkController.return(null, null, keyRemainder, stack)\n        } else {\n          // node found, continuing search\n          walkController.only(branchIndex)\n        }\n      }\n    } else if (node.type === 'leaf') {\n      if (doKeysMatch(keyRemainder, nodeKey)) {\n        // keys match, return node with empty key\n        walkController.return(null, node, [], stack)\n      } else {\n        // reached leaf but keys dont match\n        walkController.return(null, null, keyRemainder, stack)\n      }\n    } else if (node.type === 'extention') {\n      if (matchingLen !== nodeKey.length) {\n        // keys dont match, fail\n        walkController.return(null, null, keyRemainder, stack)\n      } else {\n        // keys match, continue search\n        walkController.next()\n      }\n    }\n  }\n}\n\n/*\n * Finds all nodes that store k,v values\n */\nTrie.prototype._findNode = function (key, root, stack, cb) {\n  this.findPath(key, function () {\n    cb.apply(null, arguments)\n  })\n}\n\n/*\n * Finds all nodes that store k,v values\n */\nTrie.prototype._findValueNodes = function (onFound, cb) {\n  this._walkTrie(this.root, function (nodeRef, node, key, walkController) {\n    var fullKey = key\n\n    if (node.key) {\n      fullKey = key.concat(node.key)\n    }\n\n    if (node.type === 'leaf') {\n      // found leaf node!\n      onFound(nodeRef, node, fullKey, walkController.next)\n    } else if (node.type === 'branch' && node.value) {\n      // found branch with value\n      onFound(nodeRef, node, fullKey, walkController.next)\n    } else {\n      // keep looking for value nodes\n      walkController.next()\n    }\n  }, cb)\n}\n\n/*\n * Finds all nodes that are stored directly in the db\n * (some nodes are stored raw inside other nodes)\n */\nTrie.prototype._findDbNodes = function (onFound, cb) {\n  this._walkTrie(this.root, function (nodeRef, node, key, walkController) {\n    if (TrieNode.isRawNode(nodeRef)) {\n      walkController.next()\n    } else {\n      onFound(nodeRef, node, key, walkController.next)\n    }\n  }, cb)\n}\n\n/**\n * Updates a node\n * @method _updateNode\n * @param {Buffer} key\n * @param {Buffer| String} value\n * @param {Array} keyRemainder\n * @param {Array} stack -\n * @param {Function} cb - the callback\n */\nTrie.prototype._updateNode = function (key, value, keyRemainder, stack, cb) {\n  var toSave = []\n  var lastNode = stack.pop()\n\n  // add the new nodes\n  key = TrieNode.stringToNibbles(key)\n\n  // Check if the last node is a leaf and the key matches to this\n  var matchLeaf = false\n  if (lastNode.type === 'leaf') {\n    var l = 0\n    for (var i = 0; i < stack.length; i++) {\n      var n = stack[i]\n      if (n.type === 'branch') {\n        l++\n      } else {\n        l += n.key.length\n      }\n    }\n    if ((matchingNibbleLength(lastNode.key, key.slice(l)) === lastNode.key.length) && (keyRemainder.length === 0)) {\n      matchLeaf = true\n    }\n  }\n\n  if (matchLeaf) {\n    // just updating a found value\n    lastNode.value = value\n    stack.push(lastNode)\n  } else if (lastNode.type === 'branch') {\n    stack.push(lastNode)\n    if (keyRemainder !== 0) {\n      // add an extention to a branch node\n      keyRemainder.shift()\n      // create a new leaf\n      var newLeaf = new TrieNode('leaf', keyRemainder, value)\n      stack.push(newLeaf)\n    } else {\n      lastNode.value = value\n    }\n  } else {\n    // create a branch node\n    var lastKey = lastNode.key\n    var matchingLength = matchingNibbleLength(lastKey, keyRemainder)\n    var newBranchNode = new TrieNode('branch')\n\n    // create a new extention node\n    if (matchingLength !== 0) {\n      var newKey = lastNode.key.slice(0, matchingLength)\n      var newExtNode = new TrieNode('extention', newKey, value)\n      stack.push(newExtNode)\n      lastKey.splice(0, matchingLength)\n      keyRemainder.splice(0, matchingLength)\n    }\n\n    stack.push(newBranchNode)\n\n    if (lastKey.length !== 0) {\n      var branchKey = lastKey.shift()\n      if (lastKey.length !== 0 || lastNode.type === 'leaf') {\n        // shriking extention or leaf\n        lastNode.key = lastKey\n        var formatedNode = this._formatNode(lastNode, false, toSave)\n        newBranchNode.setValue(branchKey, formatedNode)\n      } else {\n        // remove extention or attaching\n        this._formatNode(lastNode, false, true, toSave)\n        newBranchNode.setValue(branchKey, lastNode.value)\n      }\n    } else {\n      newBranchNode.value = lastNode.value\n    }\n\n    if (keyRemainder.length !== 0) {\n      keyRemainder.shift()\n      // add a leaf node to the new branch node\n      var newLeafNode = new TrieNode('leaf', keyRemainder, value)\n      stack.push(newLeafNode)\n    } else {\n      newBranchNode.value = value\n    }\n  }\n\n  this._saveStack(key, stack, toSave, cb)\n}\n\n// walk tree\n\nTrie.prototype._walkTrie = function (root, onNode, onDone) {\n  var self = this\n  root = root || self.root\n  onDone = onDone || function () {}\n  var aborted = false\n  var returnValues = []\n\n  if (root.toString('hex') === ethUtil.SHA3_RLP.toString('hex')) {\n    return onDone()\n  }\n\n  self._lookupNode(root, function (node) {\n    processNode(root, node, null, function (err) {\n      if (err) {\n        return onDone(err)\n      }\n      onDone.apply(null, returnValues)\n    })\n  })\n\n  // the maximum pool size should be high enough to utilise the parallelizability of reading nodes from disk and\n  // low enough to utilize the prioritisation of node lookup.\n  var maxPoolSize = 500\n  var taskExecutor = new PrioritizedTaskExecutor(maxPoolSize)\n\n  function processNode (nodeRef, node, key, cb) {\n    if (!node) return cb()\n    if (aborted) return cb()\n    var stopped = false\n    key = key || []\n\n    var walkController = {\n      stop: function () {\n        stopped = true\n        cb()\n      },\n      // end all traversal and return values to the onDone cb\n      return: function () {\n        aborted = true\n        returnValues = arguments\n        cb()\n      },\n      next: function () {\n        if (aborted) {\n          return cb()\n        }\n        if (stopped) {\n          return cb()\n        }\n        var children = node.getChildren()\n        async.forEachOf(children, function (childData, index, cb) {\n          var keyExtension = childData[0]\n          var childRef = childData[1]\n          var childKey = key.concat(keyExtension)\n          var priority = childKey.length\n          taskExecutor.execute(priority, function (taskCallback) {\n            self._lookupNode(childRef, function (childNode) {\n              taskCallback()\n              processNode(childRef, childNode, childKey, cb)\n            })\n          })\n        }, cb)\n      },\n      only: function (childIndex) {\n        var childRef = node.getValue(childIndex)\n        var childKey = key.slice()\n        childKey.push(childIndex)\n        var priority = childKey.length\n        taskExecutor.execute(priority, function (taskCallback) {\n          self._lookupNode(childRef, function (childNode) {\n            taskCallback()\n            processNode(childRef, childNode, childKey, cb)\n          })\n        })\n      }\n    }\n    onNode(nodeRef, node, key, walkController)\n  }\n}\n\n/**\n * saves a stack\n * @method _saveStack\n * @param {Array} key - the key. Should follow the stack\n * @param {Array} stack - a stack of nodes to the value given by the key\n * @param {Array} opStack - a stack of levelup operations to commit at the end of this funciton\n * @param {Function} cb\n */\nTrie.prototype._saveStack = function (key, stack, opStack, cb) {\n  var lastRoot\n\n  // update nodes\n  while (stack.length) {\n    var node = stack.pop()\n    if (node.type === 'leaf') {\n      key.splice(key.length - node.key.length)\n    } else if (node.type === 'extention') {\n      key.splice(key.length - node.key.length)\n      if (lastRoot) {\n        node.value = lastRoot\n      }\n    } else if (node.type === 'branch') {\n      if (lastRoot) {\n        var branchKey = key.pop()\n        node.setValue(branchKey, lastRoot)\n      }\n    }\n    lastRoot = this._formatNode(node, stack.length === 0, opStack)\n  }\n\n  if (lastRoot) {\n    this.root = lastRoot\n  }\n\n  this._batchNodes(opStack, cb)\n}\n\nTrie.prototype._deleteNode = function (key, stack, cb) {\n  function processBranchNode (key, branchKey, branchNode, parentNode, stack) {\n    // branchNode is the node ON the branch node not THE branch node\n    var branchNodeKey = branchNode.key\n    if (!parentNode || parentNode.type === 'branch') {\n      // branch->?\n      if (parentNode) {\n        stack.push(parentNode)\n      }\n\n      if (branchNode.type === 'branch') {\n        // create an extention node\n        // branch->extention->branch\n        var extentionNode = new TrieNode('extention', [branchKey], null)\n        stack.push(extentionNode)\n        key.push(branchKey)\n      } else {\n        // branch key is an extention or a leaf\n        // branch->(leaf or extention)\n        branchNodeKey.unshift(branchKey)\n        branchNode.key = branchNodeKey\n\n        // hackery. This is equvilant to array.concat except we need keep the\n        // rerfance to the `key` that was passed in.\n        branchNodeKey.unshift(0)\n        branchNodeKey.unshift(key.length)\n        key.splice.apply(key, branchNodeKey)\n      }\n      stack.push(branchNode)\n    } else {\n      // parent is a extention\n      var parentKey = parentNode.key\n      if (branchNode.type === 'branch') {\n        // ext->branch\n        parentKey.push(branchKey)\n        key.push(branchKey)\n        parentNode.key = parentKey\n        stack.push(parentNode)\n      } else {\n        // branch node is an leaf or extention and parent node is an exstention\n        // add two keys together\n        // dont push the parent node\n        branchNodeKey.unshift(branchKey)\n        key = key.concat(branchNodeKey)\n        parentKey = parentKey.concat(branchNodeKey)\n        branchNode.key = parentKey\n      }\n      stack.push(branchNode)\n    }\n\n    return key\n  }\n\n  var lastNode = stack.pop()\n  var parentNode = stack.pop()\n  var opStack = []\n  var self = this\n\n  if (!Array.isArray(key)) {\n    // convert key to nibbles\n    key = TrieNode.stringToNibbles(key)\n  }\n\n  if (!parentNode) {\n    // the root here has to be a leaf.\n    this.root = this.EMPTY_TRIE_ROOT\n    cb()\n  } else {\n    if (lastNode.type === 'branch') {\n      lastNode.value = null\n    } else {\n      // the lastNode has to be a leaf if its not a branch. And a leaf's parent\n      // if it has one must be a branch.\n      var lastNodeKey = lastNode.key\n      key.splice(key.length - lastNodeKey.length)\n      // delete the value\n      this._formatNode(lastNode, false, true, opStack)\n      parentNode.setValue(key.pop(), null)\n      lastNode = parentNode\n      parentNode = stack.pop()\n    }\n\n    // nodes on the branch\n    var branchNodes = []\n    // count the number of nodes on the branch\n    lastNode.raw.forEach(function (node, i) {\n      var val = lastNode.getValue(i)\n      if (val) branchNodes.push([i, val])\n    })\n\n    // if there is only one branch node left, collapse the branch node\n    if (branchNodes.length === 1) {\n      // add the one remaing branch node to node above it\n      var branchNode = branchNodes[0][1]\n      var branchNodeKey = branchNodes[0][0]\n\n      // look up node\n      this._lookupNode(branchNode, function (foundNode) {\n        key = processBranchNode(key, branchNodeKey, foundNode, parentNode, stack, opStack)\n        self._saveStack(key, stack, opStack, cb)\n      })\n    } else {\n      // simple removing a leaf and recaluclation the stack\n      if (parentNode) {\n        stack.push(parentNode)\n      }\n\n      stack.push(lastNode)\n      self._saveStack(key, stack, opStack, cb)\n    }\n  }\n}\n\n// Creates the initial node from an empty tree\nTrie.prototype._createInitialNode = function (key, value, cb) {\n  var newNode = new TrieNode('leaf', key, value)\n  this.root = newNode.hash()\n  this._putNode(newNode, cb)\n}\n\n// formats node to be saved by levelup.batch.\n// returns either the hash that will be used key or the rawNode\nTrie.prototype._formatNode = function (node, topLevel, remove, opStack) {\n  if (arguments.length === 3) {\n    opStack = remove\n    remove = false\n  }\n\n  var rlpNode = node.serialize()\n  if (rlpNode.length >= 32 || topLevel) {\n    var hashRoot = node.hash()\n\n    if (remove && this.isCheckpoint) {\n      opStack.push({\n        type: 'del',\n        key: hashRoot\n      })\n    } else {\n      opStack.push({\n        type: 'put',\n        key: hashRoot,\n        value: rlpNode\n      })\n    }\n    return hashRoot\n  }\n  return node.raw\n}\n\n/**\n * The `data` event is given an `Object` hat has two properties; the `key` and the `value`. Both should be Buffers.\n * @method createReadStream\n * @return {stream.Readable} Returns a [stream](https://nodejs.org/dist/latest-v5.x/docs/api/stream.html#stream_class_stream_readable) of the contents of the `trie`\n */\nTrie.prototype.createReadStream = function () {\n  return new ReadStream(this)\n}\n\n// creates a new trie backed by the same db\n// and starting at the same root\nTrie.prototype.copy = function () {\n  return new Trie(this.db, this.root)\n}\n\n/**\n * The given hash of operations (key additions or deletions) are executed on the DB\n * @method batch\n * @example\n * var ops = [\n *    { type: 'del', key: 'father' }\n *  , { type: 'put', key: 'name', value: 'Yuri Irsenovich Kim' }\n *  , { type: 'put', key: 'dob', value: '16 February 1941' }\n *  , { type: 'put', key: 'spouse', value: 'Kim Young-sook' }\n *  , { type: 'put', key: 'occupation', value: 'Clown' }\n * ]\n * trie.batch(ops)\n * @param {Array} ops\n * @param {Function} cb\n */\nTrie.prototype.batch = function (ops, cb) {\n  var self = this\n\n  async.eachSeries(ops, function (op, cb2) {\n    if (op.type === 'put') {\n      self.put(op.key, op.value, cb2)\n    } else if (op.type === 'del') {\n      self.del(op.key, cb2)\n    } else {\n      cb2()\n    }\n  }, cb)\n}\n\n/**\n * Checks if a given root exists\n * @method checkRoot\n * @param {Buffer} root\n * @param {Function} cb\n */\nTrie.prototype.checkRoot = function (root, cb) {\n  root = ethUtil.toBuffer(root)\n  this._lookupNode(root, function (value) {\n    cb(null, !!value)\n  })\n}\n"]},"metadata":{},"sourceType":"script"}
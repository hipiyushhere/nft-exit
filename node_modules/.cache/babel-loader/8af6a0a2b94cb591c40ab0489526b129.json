{"ast":null,"code":"const levelup = require('levelup');\n\nconst memdown = require('memdown');\n\nconst async = require('async');\n\nconst inherits = require('util').inherits;\n\nconst Readable = require('readable-stream').Readable;\n\nconst levelws = require('level-ws');\n\nconst callTogether = require('./util').callTogether;\n\nmodule.exports = checkpointInterface;\n\nfunction checkpointInterface(trie) {\n  this._scratch = null;\n  trie._checkpoints = [];\n  Object.defineProperty(trie, 'isCheckpoint', {\n    get: function () {\n      return !!trie._checkpoints.length;\n    }\n  }); // new methods\n\n  trie.checkpoint = checkpoint;\n  trie.commit = commit;\n  trie.revert = revert;\n  trie._enterCpMode = _enterCpMode;\n  trie._exitCpMode = _exitCpMode;\n  trie.createScratchReadStream = createScratchReadStream; // overwrites\n\n  trie.copy = copy.bind(trie, trie.copy.bind(trie));\n}\n/**\n * Creates a checkpoint that can later be reverted to or committed. After this is called, no changes to the trie will be permanently saved until `commit` is called\n * @method checkpoint\n */\n\n\nfunction checkpoint() {\n  var self = this;\n  var wasCheckpoint = self.isCheckpoint;\n\n  self._checkpoints.push(self.root);\n\n  if (!wasCheckpoint && self.isCheckpoint) {\n    self._enterCpMode();\n  }\n}\n/**\n * commits a checkpoint to disk\n * @method commit\n * @param {Function} cb the callback\n */\n\n\nfunction commit(cb) {\n  var self = this;\n  cb = callTogether(cb, self.sem.leave);\n  self.sem.take(function () {\n    if (self.isCheckpoint) {\n      self._checkpoints.pop();\n\n      if (!self.isCheckpoint) {\n        self._exitCpMode(true, cb);\n      } else {\n        cb();\n      }\n    } else {\n      throw new Error('trying to commit when not checkpointed');\n    }\n  });\n}\n/**\n * Reverts the trie to the state it was at when `checkpoint` was first called.\n * @method revert\n * @param {Function} cb the callback\n */\n\n\nfunction revert(cb) {\n  var self = this;\n  cb = callTogether(cb, self.sem.leave);\n  self.sem.take(function () {\n    if (self.isCheckpoint) {\n      self.root = self._checkpoints.pop();\n\n      if (!self.isCheckpoint) {\n        self._exitCpMode(false, cb);\n\n        return;\n      }\n    }\n\n    cb();\n  });\n} // enter into checkpoint mode\n\n\nfunction _enterCpMode() {\n  this._scratch = levelup('', {\n    db: memdown\n  });\n  this._getDBs = [this._scratch].concat(this._getDBs);\n  this.__putDBs = this._putDBs;\n  this._putDBs = [this._scratch];\n  this._putRaw = this.putRaw;\n  this.putRaw = putRaw;\n} // exit from checkpoint mode\n\n\nfunction _exitCpMode(commitState, cb) {\n  var self = this;\n  var scratch = this._scratch;\n  this._scratch = null;\n  this._getDBs = this._getDBs.slice(1);\n  this._putDBs = this.__putDBs;\n  this.putRaw = this._putRaw;\n\n  function flushScratch(db, cb) {\n    if (!db.createWriteStream) {\n      db = levelws(db);\n    }\n\n    self.createScratchReadStream(scratch).pipe(db.createWriteStream()).on('close', cb);\n  }\n\n  if (commitState) {\n    async.map(this._putDBs, flushScratch, cb);\n  } else {\n    cb();\n  }\n} // adds the interface when copying the trie\n\n\nfunction copy(_super) {\n  var trie = _super();\n\n  checkpointInterface.call(trie, trie);\n  trie._scratch = this._scratch; // trie._checkpoints = this._checkpoints.slice()\n\n  return trie;\n}\n\nfunction putRaw(key, val, cb) {\n  function dbPut(db, cb2) {\n    db.put(key, val, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, cb2);\n  }\n\n  async.each(this.__putDBs, dbPut, cb);\n}\n\nfunction createScratchReadStream(scratch) {\n  var trie = this.copy();\n  scratch = scratch || this._scratch; // only read from the scratch\n\n  trie._getDBs = [scratch];\n  trie._scratch = scratch;\n  return new ScratchReadStream(trie);\n} // ScratchReadStream\n// this is used to minimally dump the scratch into the db\n\n\ninherits(ScratchReadStream, Readable);\n\nfunction ScratchReadStream(trie) {\n  this.trie = trie;\n  this.next = null;\n  Readable.call(this, {\n    objectMode: true\n  });\n}\n\nScratchReadStream.prototype._read = function () {\n  var self = this;\n\n  if (!self._started) {\n    self._started = true;\n\n    self.trie._findDbNodes(function (nodeRef, node, key, next) {\n      self.push({\n        key: nodeRef,\n        value: node.serialize()\n      });\n      next();\n    }, function () {\n      // close stream\n      self.push(null);\n    });\n  }\n};","map":{"version":3,"sources":["/Users/piyushmaheshwari/Downloads/pos-plasma-tutorial-exit-pos-plasma/node_modules/merkle-patricia-tree/checkpoint-interface.js"],"names":["levelup","require","memdown","async","inherits","Readable","levelws","callTogether","module","exports","checkpointInterface","trie","_scratch","_checkpoints","Object","defineProperty","get","length","checkpoint","commit","revert","_enterCpMode","_exitCpMode","createScratchReadStream","copy","bind","self","wasCheckpoint","isCheckpoint","push","root","cb","sem","leave","take","pop","Error","db","_getDBs","concat","__putDBs","_putDBs","_putRaw","putRaw","commitState","scratch","slice","flushScratch","createWriteStream","pipe","on","map","_super","call","key","val","dbPut","cb2","put","keyEncoding","valueEncoding","each","ScratchReadStream","next","objectMode","prototype","_read","_started","_findDbNodes","nodeRef","node","value","serialize"],"mappings":"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","sourcesContent":["const levelup = require('levelup')\nconst memdown = require('memdown')\nconst async = require('async')\nconst inherits = require('util').inherits\nconst Readable = require('readable-stream').Readable\nconst levelws = require('level-ws')\nconst callTogether = require('./util').callTogether\n\nmodule.exports = checkpointInterface\n\nfunction checkpointInterface (trie) {\n  this._scratch = null\n  trie._checkpoints = []\n\n  Object.defineProperty(trie, 'isCheckpoint', {\n    get: function () {\n      return !!trie._checkpoints.length\n    }\n  })\n\n  // new methods\n  trie.checkpoint = checkpoint\n  trie.commit = commit\n  trie.revert = revert\n  trie._enterCpMode = _enterCpMode\n  trie._exitCpMode = _exitCpMode\n  trie.createScratchReadStream = createScratchReadStream\n\n  // overwrites\n  trie.copy = copy.bind(trie, trie.copy.bind(trie))\n}\n\n/**\n * Creates a checkpoint that can later be reverted to or committed. After this is called, no changes to the trie will be permanently saved until `commit` is called\n * @method checkpoint\n */\nfunction checkpoint () {\n  var self = this\n  var wasCheckpoint = self.isCheckpoint\n  self._checkpoints.push(self.root)\n  if (!wasCheckpoint && self.isCheckpoint) {\n    self._enterCpMode()\n  }\n}\n\n/**\n * commits a checkpoint to disk\n * @method commit\n * @param {Function} cb the callback\n */\nfunction commit (cb) {\n  var self = this\n  cb = callTogether(cb, self.sem.leave)\n\n  self.sem.take(function () {\n    if (self.isCheckpoint) {\n      self._checkpoints.pop()\n      if (!self.isCheckpoint) {\n        self._exitCpMode(true, cb)\n      } else {\n        cb()\n      }\n    } else {\n      throw new Error('trying to commit when not checkpointed')\n    }\n  })\n}\n\n/**\n * Reverts the trie to the state it was at when `checkpoint` was first called.\n * @method revert\n * @param {Function} cb the callback\n */\nfunction revert (cb) {\n  var self = this\n  cb = callTogether(cb, self.sem.leave)\n\n  self.sem.take(function () {\n    if (self.isCheckpoint) {\n      self.root = self._checkpoints.pop()\n      if (!self.isCheckpoint) {\n        self._exitCpMode(false, cb)\n        return\n      }\n    }\n\n    cb()\n  })\n}\n\n// enter into checkpoint mode\nfunction _enterCpMode () {\n  this._scratch = levelup('', {\n    db: memdown\n  })\n  this._getDBs = [this._scratch].concat(this._getDBs)\n  this.__putDBs = this._putDBs\n  this._putDBs = [this._scratch]\n  this._putRaw = this.putRaw\n  this.putRaw = putRaw\n}\n\n// exit from checkpoint mode\nfunction _exitCpMode (commitState, cb) {\n  var self = this\n  var scratch = this._scratch\n  this._scratch = null\n  this._getDBs = this._getDBs.slice(1)\n  this._putDBs = this.__putDBs\n  this.putRaw = this._putRaw\n\n  function flushScratch (db, cb) {\n    if (!db.createWriteStream) {\n      db = levelws(db)\n    }\n\n    self.createScratchReadStream(scratch)\n      .pipe(db.createWriteStream())\n      .on('close', cb)\n  }\n\n  if (commitState) {\n    async.map(this._putDBs, flushScratch, cb)\n  } else {\n    cb()\n  }\n}\n\n// adds the interface when copying the trie\nfunction copy (_super) {\n  var trie = _super()\n  checkpointInterface.call(trie, trie)\n  trie._scratch = this._scratch\n  // trie._checkpoints = this._checkpoints.slice()\n  return trie\n}\n\nfunction putRaw (key, val, cb) {\n  function dbPut (db, cb2) {\n    db.put(key, val, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, cb2)\n  }\n  async.each(this.__putDBs, dbPut, cb)\n}\n\nfunction createScratchReadStream (scratch) {\n  var trie = this.copy()\n  scratch = scratch || this._scratch\n  // only read from the scratch\n  trie._getDBs = [scratch]\n  trie._scratch = scratch\n  return new ScratchReadStream(trie)\n}\n\n// ScratchReadStream\n// this is used to minimally dump the scratch into the db\n\ninherits(ScratchReadStream, Readable)\n\nfunction ScratchReadStream (trie) {\n  this.trie = trie\n  this.next = null\n  Readable.call(this, {\n    objectMode: true\n  })\n}\n\nScratchReadStream.prototype._read = function () {\n  var self = this\n  if (!self._started) {\n    self._started = true\n    self.trie._findDbNodes(function (nodeRef, node, key, next) {\n      self.push({\n        key: nodeRef,\n        value: node.serialize()\n      })\n      next()\n    }, function () {\n      // close stream\n      self.push(null)\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}
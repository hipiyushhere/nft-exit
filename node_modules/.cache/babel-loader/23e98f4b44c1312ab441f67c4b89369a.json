{"ast":null,"code":"const async = require('async');\n\nmodule.exports = {\n  matchingNibbleLength: matchingNibbleLength,\n  callTogether: callTogether,\n  asyncFirstSeries: asyncFirstSeries,\n  doKeysMatch: doKeysMatch\n};\n/**\n * Returns the number of in order matching nibbles of two give nibble arrayes\n * @method matchingNibbleLength\n * @param {Array} nib1\n * @param {Array} nib2\n */\n\nfunction matchingNibbleLength(nib1, nib2) {\n  var i = 0;\n\n  while (nib1[i] === nib2[i] && nib1.length > i) {\n    i++;\n  }\n\n  return i;\n}\n/**\n * Compare two 'nibble array' keys\n */\n\n\nfunction doKeysMatch(keyA, keyB) {\n  var length = matchingNibbleLength(keyA, keyB);\n  return length === keyA.length && length === keyB.length;\n}\n/**\n * Take two or more functions and returns a function  that will execute all of\n * the given functions\n */\n\n\nfunction callTogether() {\n  var funcs = arguments;\n  var length = funcs.length;\n  var index = length;\n\n  if (!length) {\n    return function () {};\n  }\n\n  return function () {\n    length = index;\n\n    while (length--) {\n      var fn = funcs[length];\n\n      if (typeof fn === 'function') {\n        var result = funcs[length].apply(this, arguments);\n      }\n    }\n\n    return result;\n  };\n}\n/**\n * Take a collection of async fns, call the cb on the first to return a truthy value.\n * If all run without a truthy result, return undefined\n */\n\n\nfunction asyncFirstSeries(array, iterator, cb) {\n  var didComplete = false;\n  async.eachSeries(array, function (item, next) {\n    if (didComplete) return next;\n    iterator(item, function (err, result) {\n      if (result) {\n        didComplete = true;\n        process.nextTick(cb.bind(null, null, result));\n      }\n\n      next(err);\n    });\n  }, function () {\n    if (!didComplete) {\n      cb();\n    }\n  });\n}","map":{"version":3,"sources":["/Users/piyushmaheshwari/Downloads/pos-plasma-tutorial-exit-pos-plasma/node_modules/merkle-patricia-tree/util.js"],"names":["async","require","module","exports","matchingNibbleLength","callTogether","asyncFirstSeries","doKeysMatch","nib1","nib2","i","length","keyA","keyB","funcs","arguments","index","fn","result","apply","array","iterator","cb","didComplete","eachSeries","item","next","err","process","nextTick","bind"],"mappings":"AAAA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AAEAC,MAAM,CAACC,OAAP,GAAiB;AACfC,EAAAA,oBAAoB,EAAEA,oBADP;AAEfC,EAAAA,YAAY,EAAEA,YAFC;AAGfC,EAAAA,gBAAgB,EAAEA,gBAHH;AAIfC,EAAAA,WAAW,EAAEA;AAJE,CAAjB;AAOA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASH,oBAAT,CAA+BI,IAA/B,EAAqCC,IAArC,EAA2C;AACzC,MAAIC,CAAC,GAAG,CAAR;;AACA,SAAOF,IAAI,CAACE,CAAD,CAAJ,KAAYD,IAAI,CAACC,CAAD,CAAhB,IAAuBF,IAAI,CAACG,MAAL,GAAcD,CAA5C,EAA+C;AAC7CA,IAAAA,CAAC;AACF;;AACD,SAAOA,CAAP;AACD;AAED;AACA;AACA;;;AACA,SAASH,WAAT,CAAsBK,IAAtB,EAA4BC,IAA5B,EAAkC;AAChC,MAAIF,MAAM,GAAGP,oBAAoB,CAACQ,IAAD,EAAOC,IAAP,CAAjC;AACA,SAAOF,MAAM,KAAKC,IAAI,CAACD,MAAhB,IAA0BA,MAAM,KAAKE,IAAI,CAACF,MAAjD;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASN,YAAT,GAAyB;AACvB,MAAIS,KAAK,GAAGC,SAAZ;AACA,MAAIJ,MAAM,GAAGG,KAAK,CAACH,MAAnB;AACA,MAAIK,KAAK,GAAGL,MAAZ;;AAEA,MAAI,CAACA,MAAL,EAAa;AACX,WAAO,YAAY,CAAE,CAArB;AACD;;AAED,SAAO,YAAY;AACjBA,IAAAA,MAAM,GAAGK,KAAT;;AAEA,WAAOL,MAAM,EAAb,EAAiB;AACf,UAAIM,EAAE,GAAGH,KAAK,CAACH,MAAD,CAAd;;AACA,UAAI,OAAOM,EAAP,KAAc,UAAlB,EAA8B;AAC5B,YAAIC,MAAM,GAAGJ,KAAK,CAACH,MAAD,CAAL,CAAcQ,KAAd,CAAoB,IAApB,EAA0BJ,SAA1B,CAAb;AACD;AACF;;AACD,WAAOG,MAAP;AACD,GAVD;AAWD;AAED;AACA;AACA;AACA;;;AACA,SAASZ,gBAAT,CAA2Bc,KAA3B,EAAkCC,QAAlC,EAA4CC,EAA5C,EAAgD;AAC9C,MAAIC,WAAW,GAAG,KAAlB;AACAvB,EAAAA,KAAK,CAACwB,UAAN,CAAiBJ,KAAjB,EAAwB,UAAUK,IAAV,EAAgBC,IAAhB,EAAsB;AAC5C,QAAIH,WAAJ,EAAiB,OAAOG,IAAP;AACjBL,IAAAA,QAAQ,CAACI,IAAD,EAAO,UAAUE,GAAV,EAAeT,MAAf,EAAuB;AACpC,UAAIA,MAAJ,EAAY;AACVK,QAAAA,WAAW,GAAG,IAAd;AACAK,QAAAA,OAAO,CAACC,QAAR,CAAiBP,EAAE,CAACQ,IAAH,CAAQ,IAAR,EAAc,IAAd,EAAoBZ,MAApB,CAAjB;AACD;;AACDQ,MAAAA,IAAI,CAACC,GAAD,CAAJ;AACD,KANO,CAAR;AAOD,GATD,EASG,YAAY;AACb,QAAI,CAACJ,WAAL,EAAkB;AAChBD,MAAAA,EAAE;AACH;AACF,GAbD;AAcD","sourcesContent":["const async = require('async')\n\nmodule.exports = {\n  matchingNibbleLength: matchingNibbleLength,\n  callTogether: callTogether,\n  asyncFirstSeries: asyncFirstSeries,\n  doKeysMatch: doKeysMatch\n}\n\n/**\n * Returns the number of in order matching nibbles of two give nibble arrayes\n * @method matchingNibbleLength\n * @param {Array} nib1\n * @param {Array} nib2\n */\nfunction matchingNibbleLength (nib1, nib2) {\n  var i = 0\n  while (nib1[i] === nib2[i] && nib1.length > i) {\n    i++\n  }\n  return i\n}\n\n/**\n * Compare two 'nibble array' keys\n */\nfunction doKeysMatch (keyA, keyB) {\n  var length = matchingNibbleLength(keyA, keyB)\n  return length === keyA.length && length === keyB.length\n}\n\n/**\n * Take two or more functions and returns a function  that will execute all of\n * the given functions\n */\nfunction callTogether () {\n  var funcs = arguments\n  var length = funcs.length\n  var index = length\n\n  if (!length) {\n    return function () {}\n  }\n\n  return function () {\n    length = index\n\n    while (length--) {\n      var fn = funcs[length]\n      if (typeof fn === 'function') {\n        var result = funcs[length].apply(this, arguments)\n      }\n    }\n    return result\n  }\n}\n\n/**\n * Take a collection of async fns, call the cb on the first to return a truthy value.\n * If all run without a truthy result, return undefined\n */\nfunction asyncFirstSeries (array, iterator, cb) {\n  var didComplete = false\n  async.eachSeries(array, function (item, next) {\n    if (didComplete) return next\n    iterator(item, function (err, result) {\n      if (result) {\n        didComplete = true\n        process.nextTick(cb.bind(null, null, result))\n      }\n      next(err)\n    })\n  }, function () {\n    if (!didComplete) {\n      cb()\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}